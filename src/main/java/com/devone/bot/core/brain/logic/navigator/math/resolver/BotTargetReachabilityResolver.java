// @Generated by ChatGPT ‚Äì reachability for the seekers of paths üòé

package com.devone.bot.core.brain.logic.navigator.math.resolver;

import java.util.*;
import java.util.stream.Collectors;

import com.devone.bot.core.utils.blocks.BotBlockData;
import com.devone.bot.core.utils.blocks.BotLocation;

public class BotTargetReachabilityResolver {
    
    public enum Strategy {
        ADAPTIVE_SECTOR,
        EVEN_DISTRIBUTED
    }


    private static boolean isBotStandingOn(BotLocation botPosition, BotLocation block) {
        return block.getX() == botPosition.getX()
            && block.getY() == botPosition.getY() - 1
            && block.getZ() == botPosition.getZ();
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –¥–æ—Å—Ç–∏–∂–∏–º–∞ –ª–∏ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∞—è —Ç–æ—á–∫–∞ target –∏–∑ –ø–æ–∑–∏—Ü–∏–∏ botPosition,
     * –æ—Å–Ω–æ–≤—ã–≤–∞—è—Å—å –Ω–∞ —Å–ø–∏—Å–∫–µ –Ω–∞–≤–∏–≥–∞—Ü–∏–æ–Ω–Ω–æ –ø—Ä–æ—Ö–æ–¥–∏–º—ã—Ö —Ç–æ—á–µ–∫.
     */
    public static boolean isReachable(BotLocation botPosition,
                                      BotLocation target,
                                      List<BotBlockData> navigablePoints) {

        if(isBotStandingOn(botPosition, target)) { return false; }  // exclude a block the bot is standing on

        //if (botPosition.equals(target)) return true;

        Set<String> visited = new HashSet<>();
        Queue<BotLocation> queue = new LinkedList<>();
        queue.add(botPosition);
        visited.add(coordKey(botPosition));

        Set<String> navigableSet = navigablePoints.stream()
                .map(BotTargetReachabilityResolver::coordKey)
                .collect(Collectors.toSet());

        while (!queue.isEmpty()) {
            BotLocation current = queue.poll();

            for (int dx = -1; dx <= 1; dx++) {
                for (int dy = -1; dy <= 1; dy++) {
                    for (int dz = -1; dz <= 1; dz++) {
                        if (Math.abs(dx) + Math.abs(dy) + Math.abs(dz) != 1) continue;

                        BotLocation neighbor = new BotLocation(
                                current.getX() + dx,
                                current.getY() + dy,
                                current.getZ() + dz);

                        String key = coordKey(neighbor);
                        if (!navigableSet.contains(key) || visited.contains(key)) continue;

                        if (neighbor.equals(target)) return true;

                        visited.add(key);
                        queue.add(neighbor);
                    }
                }
            }
        }

        return false;
    }

    public static List<BotBlockData> selectTargets(BotLocation bot,
                                                    List<BotBlockData> reachable,
                                                    Strategy strategy,
                                                    int sectorCount,
                                                    int maxTargets,
                                                    boolean preferDistant,
                                                    int scanRadius) {
 
         if (reachable == null || reachable.isEmpty()) return null;
 
         switch (strategy) {
             case ADAPTIVE_SECTOR:
                 return selectAdaptiveSectorTargets(reachable, bot, sectorCount);
             case EVEN_DISTRIBUTED:
                 return findEvenlyDistributedTargets(reachable, bot, sectorCount, maxTargets, preferDistant, scanRadius);
             default:
                 return null;
         }
     }
 
     private static List<BotBlockData> selectAdaptiveSectorTargets(List<BotBlockData> reachable, BotLocation bot, int sectorCount) {
         Map<Integer, BotBlockData> bestInSector = new HashMap<>();
         Map<Integer, Double> maxDistances = new HashMap<>();
 
         for (BotBlockData point : reachable) {
             int dx = point.getX() - bot.getX();
             int dz = point.getZ() - bot.getZ();
 
             if (dx == 0 && dz == 0) continue;
 
             double angle = Math.atan2(dz, dx);
             int sector = (int) ((angle + Math.PI) / (2 * Math.PI) * sectorCount) % sectorCount;
 
             double distanceSq = dx * dx + dz * dz;
 
             if (!maxDistances.containsKey(sector) || distanceSq > maxDistances.get(sector)) {
                 bestInSector.put(sector, point);
                 maxDistances.put(sector, distanceSq);
             }
         }
 
         return new ArrayList<>(bestInSector.values());
     }
 
     private static List<BotBlockData> findEvenlyDistributedTargets(
        List<BotBlockData> reachable,
        BotLocation bot,
        int sectors,
        int maxTargetsInput,
        boolean preferDistant,
        int scanRadius) {

    if (reachable == null || reachable.isEmpty()) return List.of();

    // üìê –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–π maxTargets
    int maxTargets = estimateAdaptiveMaxTargets(reachable, scanRadius);
    if (maxTargets == 0) return List.of();

    double minRadius = (scanRadius > 3) ? scanRadius * 0.5 : 0.0;
    Map<Integer, BotBlockData> sectorMap = new HashMap<>();

    for (BotBlockData point : reachable) {
        if (point.getX() == bot.getX() && point.getZ() == bot.getZ()) continue;

        double dx = point.getX() - bot.getX();
        double dy = point.getY() - bot.getY();
        double dz = point.getZ() - bot.getZ();
        double distSq = dx * dx + dy * dy + dz * dz;
        double dist = Math.sqrt(distSq);

        if (dist < minRadius) continue;

        double angle = Math.atan2(dz, dx);
        int sector = (int) ((angle + Math.PI) / (2 * Math.PI) * sectors) % sectors;

        BotBlockData current = sectorMap.get(sector);

        if (current == null ||
                (preferDistant && distSq > squaredDistance(current, bot)) ||
                (!preferDistant && distSq < squaredDistance(current, bot))) {
            sectorMap.put(sector, point);
        }
    }

    // üß± Fallback: –¥–æ–±–∏—Ä–∞–µ–º —Å–∞–º—ã–µ —É–¥–∞–ª—ë–Ω–Ω—ã–µ
    if (sectorMap.size() < maxTargets) {
        reachable.stream()
                .filter(p -> !sectorMap.containsValue(p))
                .sorted(Comparator.comparingDouble(p -> -squaredDistance(p, bot)))
                .limit(maxTargets - sectorMap.size())
                .forEach(p -> sectorMap.put(sectorMap.size() + 1000, p));
    }

    // üéØ –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–º—É —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—é –º–µ–∂–¥—É —Ü–µ–ª—è–º–∏
    List<BotBlockData> filtered = filterByDistance(
            sectorMap.values().stream()
                    .sorted(Comparator.comparingDouble(p -> -squaredDistance(p, bot)))
                    .collect(Collectors.toList()),
            3.0  // –º–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –¥–∏—Å—Ç–∞–Ω—Ü–∏—è –º–µ–∂–¥—É —Ü–µ–ª—è–º–∏
    );

    return filtered.stream()
            .limit(maxTargets)
            .collect(Collectors.toList());
}



    private static int estimateAdaptiveMaxTargets(List<BotBlockData> reachable, int scanRadius) {
        if (reachable == null || reachable.isEmpty()) return 0;
    
        double area = Math.PI * scanRadius * scanRadius;
        double densityFactor = 0.8;
    
        int suggested = (int) Math.round(Math.min(reachable.size(), area * densityFactor));
        return Math.max(1, Math.min(suggested, reachable.size()));
    }
    
    private static double squaredDistance(BotBlockData a, BotLocation b) {
        return Math.pow(a.getX() - b.getX(), 2) + Math.pow(a.getY() - b.getY(), 2) + Math.pow(a.getZ() - b.getZ(), 2);
    }
    
    private static List<BotBlockData> filterByDistance(List<BotBlockData> candidates, double minDist) {
        List<BotBlockData> result = new ArrayList<>();
        for (BotBlockData candidate : candidates) {
            boolean tooClose = result.stream()
                    .anyMatch(p -> squaredDistance(p, candidate) < minDist * minDist);
            if (!tooClose) {
                result.add(candidate);
            }
        }
        return result;
    }

    private static String coordKey(BotLocation c) {
        return c.toString();
    }
}
